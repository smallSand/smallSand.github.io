---
layout:  post
title:  " Spring-AOP配置切入点方式及配置各种类型增强 "
date:    2016-06-01
excerpt: " AOP(Aspect-OrientedProgramming)：面向切面编程是一种通过预编译方式和运行期动态代理实现在不修改源代码的情况下给程序动态添加功能的技术AOP相关jar包：spring-aop-4.2.5.RELEASE.jaraopalliance-1.0.jaraspectjweaver-1.6.9.jarcglib-nodep-2.1_3.jar使用AOP之前先配置... "
categories: spring 
comments: true
---
转自 (csdn): http://blog.csdn.net/qq_32588349/article/details/51557143
<div class="markdown_views">
 <p><strong>AOP(Aspect-Oriented Programming)：面向切面编程</strong>  是一种通过预编译方式和运行期动态代理实现在不修改源代码的情况下给程序动态添加功能的技术</p> 
 <p><strong>AOP相关jar包：</strong>  <strong>spring-aop-4.2.5.RELEASE.jar</strong>  <strong>aopalliance-1.0.jar</strong>  <strong>aspectjweaver-1.6.9.jar</strong>  <strong>cglib-nodep-2.1_3.jar</strong></p> 
 <p><strong>使用AOP之前先配置切入点：</strong></p> 
 <pre class="prettyprint"><code class=" hljs xml">    <span class="hljs-tag">&lt;<span class="hljs-title">aop:config</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- 配置切入点 --&gt;</span>
        <span class="hljs-comment">&lt;!-- execution()语法:execution (* com.xx.xx.impl..*.*(..)) 首先明白这个表达式是用来匹配方法的,各种条件是为了筛选整个项目的方法。 (类的访问修饰符 第一个*表示方法返回值类型[*表示所有类型] com.xx.xx.impl表示包路径[*表示所有包] .[.表示当前包下所有类的方法,..表示当前包下及此包下所有子包中的所有类的方法] 第二个*表示类名[*表示所有类,可以匹配以X开头或结尾如X*、*X、X*X的类名] 第三个*表示方法名[*表示所有方法,可以匹配以X开头或结尾的如X*、*X、X*X的方法名] (..)表示方法参数[..表示任何参数] )--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">aop:pointcut</span> <span class="hljs-attribute">expression</span>=<span class="hljs-value">"execution(public * com.bc.aop..*.*(..))"</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"pointcut"</span>/&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-title">aop:config</span>&gt;</span></code></pre> 
 <h2 id="一通过advisor配置增强处理不推荐">一、通过Advisor配置增强处理(不推荐)</h2> 
 <ul> 
  <li>新建一个类MethodBeforeAdvice接口的before方法</li> 
 </ul> 
 <pre class="prettyprint"><code class=" hljs java"><span class="hljs-javadoc">/**前置增强*/</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeforeLogger</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodBeforeAdvice</span> {</span>

    <span class="hljs-keyword">private</span> Logger logger = Logger.getLogger(BeforeLogger.class);

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span>(Method arg0, Object[] arg1, Object arg2)
            <span class="hljs-keyword">throws</span> Throwable {
        logger.info(<span class="hljs-string">"Method:"</span> + arg0.getName());
        logger.info(<span class="hljs-string">"Object[]:"</span> + Arrays.toString(arg1));
        logger.info(<span class="hljs-string">"Object:"</span> + arg2.toString());
        logger.info(<span class="hljs-string">"这是BeforeLogger类的before方法！"</span>);
    }

}</code></pre> 
 <ul> 
  <li>用来测试的切入点类</li> 
 </ul> 
 <pre class="prettyprint"><code class=" hljs java"><span class="hljs-javadoc">/**测试业务类*/</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserBiz</span> {</span>

    <span class="hljs-keyword">public</span> String <span class="hljs-title">addUser</span>(String uname, String pwd) {
        System.out.println(<span class="hljs-string">"这是UserBiz类的addUser方法！"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-string">"UserBiz类的addUser方法返回值"</span>;
    }
}</code></pre> 
 <ul> 
  <li>使用<code>&lt;aop:advisor&gt;</code>配置切入点和前置增强方法</li> 
 </ul> 
 <pre class="prettyprint"><code class=" hljs cs">&lt;aop:advisor advice-<span class="hljs-keyword">ref</span>=<span class="hljs-string">"beforeLogger"</span> pointcut-<span class="hljs-keyword">ref</span>=<span class="hljs-string">"pointcut"</span>/&gt;</code></pre> 
 <ul> 
  <li><p>相关实体bean配置略</p></li> 
  <li><p>测试代码</p></li> 
 </ul> 
 <pre class="prettyprint"><code class=" hljs avrasm">        ApplicationContext ac = new ClassPathXmlApplicationContext(<span class="hljs-string">"applicationContext.xml"</span>)<span class="hljs-comment">;</span>
        UserBiz user = (UserBiz) ac<span class="hljs-preprocessor">.getBean</span>(<span class="hljs-string">"userBiz01"</span>)<span class="hljs-comment">;</span>
        user<span class="hljs-preprocessor">.addUser</span>(<span class="hljs-string">"张三"</span>, <span class="hljs-string">"李四"</span>)<span class="hljs-comment">;</span>
        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(<span class="hljs-string">"user:"</span> + user<span class="hljs-preprocessor">.toString</span>())<span class="hljs-comment">;</span></code></pre> 
 <ul> 
  <li>执行结果</li> 
 </ul> 
 <p><img src="http://img.blog.csdn.net/20160602141316081" alt="这里写图片描述" title=""></p> 
 <ul> 
  <li>这种方式不推荐使用,其他增强略</li> 
 </ul> 
 <hr> 
 <h2 id="二通过aopaspect配置实现增强">二、通过<code>&lt;aop:aspect&gt;</code>配置实现增强</h2> 
 <p><strong>先介绍下用来访问连接点上下文信息的对象</strong></p> 
 <p>AspectJ使用org.aspectj.lang.JoinPoint接口表示目标类连接点对象,如果是环绕增强时，使用org.aspectj.lang.ProceedingJoinPoint表示连接点对象，该类是JoinPoint的子接口。任何一个增强方法都可以通过将第一个入参声明为JoinPoint访问到连接点上下文的信息。我们先来了解一下这两个接口的主要方法： </p> 
 <p><strong>1)JoinPoint</strong>  - java.lang.Object[] getArgs()：获取连接点方法运行时的入参列表；  - Signature getSignature() ：获取连接点的方法签名对象；  - java.lang.Object getTarget() ：获取连接点所在的目标对象；  - java.lang.Object getThis() ：获取代理对象本身； </p> 
 <p><strong>2)ProceedingJoinPoint</strong>  ProceedingJoinPoint继承JoinPoint子接口，它新增了两个用于执行连接点方法的方法：  - java.lang.Object proceed() throws java.lang.Throwable：通过反射执行目标对象的连接点处的方法；  - java.lang.Object proceed(java.lang.Object[] args) throws java.lang.Throwable：通过反射执行目标对象连接点处的方法，不过使用新的入参替换原来的入参。 </p> 
 <p><strong>接下来是各种增强测试,相关对象bean配置略</strong></p> 
 <p><strong>增强类代码</strong></p> 
 <pre class="prettyprint"><code class=" hljs avrasm">public class MyLogger {

    private Logger logger = Logger<span class="hljs-preprocessor">.getLogger</span>(MyLogger<span class="hljs-preprocessor">.class</span>)<span class="hljs-comment">;</span>

    <span class="hljs-comment">/**前置增强方法*/</span>
    public void beforeLogger(JoinPoint jp) {
        logger<span class="hljs-preprocessor">.info</span>(<span class="hljs-string">"这是MyLogger类的before方法！"</span>)<span class="hljs-comment">;</span>
        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(<span class="hljs-string">"切入点方法入参列表："</span> + Arrays<span class="hljs-preprocessor">.toString</span>(jp<span class="hljs-preprocessor">.getArgs</span>()))<span class="hljs-comment">;</span>
        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(<span class="hljs-string">"切入点方法签名对象："</span> + jp<span class="hljs-preprocessor">.getSignature</span>())<span class="hljs-comment">;</span>
        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(<span class="hljs-string">"切入点所在目标对象："</span> + jp<span class="hljs-preprocessor">.getTarget</span>())<span class="hljs-comment">;</span>
        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(<span class="hljs-string">"代理对象本身："</span> + jp<span class="hljs-preprocessor">.getThis</span>())<span class="hljs-comment">;</span>
    }

    <span class="hljs-comment">/**后置增强方法*/</span>
    public void afterReturning(JoinPoint jp, Object result) {
        logger<span class="hljs-preprocessor">.info</span>(<span class="hljs-string">"这是MyLogger类的after-returning方法！"</span>)<span class="hljs-comment">;</span>
        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(<span class="hljs-string">"切入点方法入参列表："</span> + Arrays<span class="hljs-preprocessor">.toString</span>(jp<span class="hljs-preprocessor">.getArgs</span>()))<span class="hljs-comment">;</span>
        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(<span class="hljs-string">"切入点方法签名对象："</span> + jp<span class="hljs-preprocessor">.getSignature</span>())<span class="hljs-comment">;</span>
        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(<span class="hljs-string">"切入点所在目标对象："</span> + jp<span class="hljs-preprocessor">.getTarget</span>())<span class="hljs-comment">;</span>
        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(<span class="hljs-string">"代理对象本身："</span> + jp<span class="hljs-preprocessor">.getThis</span>())<span class="hljs-comment">;</span>
        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(<span class="hljs-string">"切入点方法返回对象："</span> + result)<span class="hljs-comment">;</span>
    }

    <span class="hljs-comment">/**后置异常增强方法*/</span>
    public void afterThrowing(JoinPoint jp, Exception e) {
        logger<span class="hljs-preprocessor">.info</span>(<span class="hljs-string">"这是MyLogger类的after-Throwing方法！"</span>)<span class="hljs-comment">;</span>
        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(<span class="hljs-string">"切入点方法入参列表："</span> + Arrays<span class="hljs-preprocessor">.toString</span>(jp<span class="hljs-preprocessor">.getArgs</span>()))<span class="hljs-comment">;</span>
        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(<span class="hljs-string">"切入点方法签名对象："</span> + jp<span class="hljs-preprocessor">.getSignature</span>())<span class="hljs-comment">;</span>
        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(<span class="hljs-string">"切入点所在目标对象："</span> + jp<span class="hljs-preprocessor">.getTarget</span>())<span class="hljs-comment">;</span>
        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(<span class="hljs-string">"代理对象本身："</span> + jp<span class="hljs-preprocessor">.getThis</span>())<span class="hljs-comment">;</span>
        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(<span class="hljs-string">"异常："</span> + e)<span class="hljs-comment">;</span>
    }

    <span class="hljs-comment">/**最终增强方法*/</span>
    public void after(JoinPoint jp) {
        logger<span class="hljs-preprocessor">.info</span>(<span class="hljs-string">"这是MyLogger类的after方法！"</span>)<span class="hljs-comment">;</span>
        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(<span class="hljs-string">"切入点方法入参列表："</span> + Arrays<span class="hljs-preprocessor">.toString</span>(jp<span class="hljs-preprocessor">.getArgs</span>()))<span class="hljs-comment">;</span>
        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(<span class="hljs-string">"切入点方法签名对象："</span> + jp<span class="hljs-preprocessor">.getSignature</span>())<span class="hljs-comment">;</span>
        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(<span class="hljs-string">"切入点所在目标对象："</span> + jp<span class="hljs-preprocessor">.getTarget</span>())<span class="hljs-comment">;</span>
        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(<span class="hljs-string">"代理对象本身："</span> + jp<span class="hljs-preprocessor">.getThis</span>())<span class="hljs-comment">;</span>
    }

    <span class="hljs-comment">/**环绕增强方法*/</span>
    public void aroundLogger(ProceedingJoinPoint jp) {
        logger<span class="hljs-preprocessor">.info</span>(<span class="hljs-string">"这是MyLogger类的around方法！"</span>)<span class="hljs-comment">;</span>
        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(<span class="hljs-string">"切入点方法入参列表："</span> + Arrays<span class="hljs-preprocessor">.toString</span>(jp<span class="hljs-preprocessor">.getArgs</span>()))<span class="hljs-comment">;</span>
        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(<span class="hljs-string">"切入点方法签名对象："</span> + jp<span class="hljs-preprocessor">.getSignature</span>())<span class="hljs-comment">;</span>
        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(<span class="hljs-string">"切入点所在目标对象："</span> + jp<span class="hljs-preprocessor">.getTarget</span>())<span class="hljs-comment">;</span>
        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(<span class="hljs-string">"代理对象本身："</span> + jp<span class="hljs-preprocessor">.getThis</span>())<span class="hljs-comment">;</span>
        System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(<span class="hljs-string">"-------------------------------"</span>)<span class="hljs-comment">;</span>
        try {
            System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(<span class="hljs-string">"执行切入点方法"</span>)<span class="hljs-comment">;</span>
            jp<span class="hljs-preprocessor">.proceed</span>()<span class="hljs-comment">;</span>
            System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(<span class="hljs-string">"-------------------------------"</span>)<span class="hljs-comment">;</span>
            System<span class="hljs-preprocessor">.out</span><span class="hljs-preprocessor">.println</span>(<span class="hljs-string">"执行切入点方法并改变参数"</span>)<span class="hljs-comment">;</span>
            jp<span class="hljs-preprocessor">.proceed</span>(new Object[]{<span class="hljs-number">7</span>})<span class="hljs-comment">;</span>
        } catch (Throwable e) {
            e<span class="hljs-preprocessor">.printStackTrace</span>()<span class="hljs-comment">;</span>
        }
    }
}</code></pre> 
 <p><strong>切入点类代码</strong></p> 
 <pre class="prettyprint"><code class=" hljs java"><span class="hljs-javadoc">/**用于AOP测试的切入点类*/</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserInfo</span> {</span>

    <span class="hljs-keyword">public</span> String <span class="hljs-title">beforeTest</span>(<span class="hljs-keyword">int</span> i) {
        System.out.println(<span class="hljs-string">"这是UserInfo类的beforeTest方法！"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-string">"beforeTest方法返回值"</span>;
    }

    <span class="hljs-keyword">public</span> String <span class="hljs-title">afterReturningTest</span>(<span class="hljs-keyword">int</span> i) {
        System.out.println(<span class="hljs-string">"这是UserInfo类的afterReturningTest方法！"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-string">"afterReturningTest方法返回值"</span>;
    }

    <span class="hljs-keyword">public</span> String <span class="hljs-title">afterThrowingTest</span>(<span class="hljs-keyword">int</span> i) {
        System.out.println(<span class="hljs-string">"这是UserInfo类的afterThrowingTest方法！"</span>);
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"afterThrowingTest方法抛出的异常"</span>);
    }

    <span class="hljs-keyword">public</span> String <span class="hljs-title">afterTest</span>(<span class="hljs-keyword">int</span> i) {
        System.out.println(<span class="hljs-string">"这是UserInfo类的afterTest方法！"</span>);
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"afterTest方法抛出的异常"</span>);
    }

    <span class="hljs-keyword">public</span> String <span class="hljs-title">aroundTest</span>(<span class="hljs-keyword">int</span> i) {
        System.out.println(<span class="hljs-string">"这是UserInfo类的aroundTest方法！参数值："</span> + i);
        <span class="hljs-keyword">return</span> <span class="hljs-string">"aroundTest方法返回值"</span>;
    }
}</code></pre> 
 <p><strong>applicationContext.xml配置</strong></p> 
 <pre class="prettyprint"><code class=" hljs xml"><span class="hljs-comment">&lt;!-- 配置多个增强方式 ref引用配置的增强类bean id--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">aop:config</span>&gt;</span>
    <span class="hljs-comment">&lt;!--配置切入点--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">aop:aspect</span> <span class="hljs-attribute">ref</span>=<span class="hljs-value">"myLogger"</span>&gt;</span>
        <span class="hljs-comment">&lt;!--配置各种类型增强--&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-title">aop:aspect</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">aop:config</span>&gt;</span></code></pre> 
 <ul> 
  <li><strong>前置增强</strong></li> 
 </ul> 
 <p>配置</p> 
 <pre class="prettyprint"><code class=" hljs oxygene">&lt;aop:before <span class="hljs-function"><span class="hljs-keyword">method</span>="<span class="hljs-title">beforeLogger</span>" <span class="hljs-title">pointcut</span>-<span class="hljs-title">ref</span>="<span class="hljs-title">pointcut</span>"/&gt;</span></code></pre> 
 <p>测试代码</p> 
 <pre class="prettyprint"><code class=" hljs cs">ApplicationContext ac = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"applicationContext.xml"</span>);
UserInfo user = (UserInfo) ac.getBean(<span class="hljs-string">"userInfo"</span>);
<span class="hljs-comment">//前置增强测试</span>
user.beforeTest(<span class="hljs-number">1</span>);</code></pre> 
 <p>控制台</p> 
 <pre class="prettyprint"><code class=" hljs avrasm"><span class="hljs-number">2016</span>-<span class="hljs-number">06</span>-<span class="hljs-number">02</span> <span class="hljs-number">15</span>:<span class="hljs-number">50</span>:<span class="hljs-number">45</span>,<span class="hljs-number">127</span> INFO [<span class="hljs-keyword">com</span><span class="hljs-preprocessor">.bc</span><span class="hljs-preprocessor">.aop</span><span class="hljs-preprocessor">.demo</span>02<span class="hljs-preprocessor">.MyLogger</span>] - 这是MyLogger类的before方法！
切入点方法入参列表：[<span class="hljs-number">1</span>]
切入点方法签名对象：String <span class="hljs-keyword">com</span><span class="hljs-preprocessor">.bc</span><span class="hljs-preprocessor">.aop</span><span class="hljs-preprocessor">.demo</span>02<span class="hljs-preprocessor">.UserInfo</span><span class="hljs-preprocessor">.beforeTest</span>(int)
切入点所在目标对象：<span class="hljs-keyword">com</span><span class="hljs-preprocessor">.bc</span><span class="hljs-preprocessor">.aop</span><span class="hljs-preprocessor">.demo</span>02<span class="hljs-preprocessor">.UserInfo</span><span class="hljs-localvars">@557</span>caf28
代理对象本身：<span class="hljs-keyword">com</span><span class="hljs-preprocessor">.bc</span><span class="hljs-preprocessor">.aop</span><span class="hljs-preprocessor">.demo</span>02<span class="hljs-preprocessor">.UserInfo</span><span class="hljs-localvars">@557</span>caf28
这是UserInfo类的beforeTest方法！</code></pre> 
 <p>结论：  <strong>从控制台输出来看,前置增强会在切入点方法执行之前执行,并可以通过JoinPoint对象获取切入点方法的相关参数,如参数列表、方法签名对象、切入点所在对象及代理对象本身。</strong></p> 
 <hr> 
 <ul> 
  <li><strong>后置增强</strong></li> 
 </ul> 
 <p>配置</p> 
 <pre class="prettyprint"><code class=" hljs oxygene">&lt;aop:after-returning <span class="hljs-function"><span class="hljs-keyword">method</span>="<span class="hljs-title">afterReturning</span>" <span class="hljs-title">pointcut</span>-<span class="hljs-title">ref</span>="<span class="hljs-title">pointcut</span>" <span class="hljs-title">returning</span>="<span class="hljs-title">result</span>"/&gt;</span></code></pre> 
 <p>测试代码</p> 
 <pre class="prettyprint"><code class=" hljs cs">ApplicationContext ac = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"applicationContext.xml"</span>);
UserInfo user = (UserInfo) ac.getBean(<span class="hljs-string">"userInfo"</span>);
<span class="hljs-comment">//后置增强测试</span>
user.afterReturningTest(<span class="hljs-number">2</span>);</code></pre> 
 <p>控制台</p> 
 <pre class="prettyprint"><code class=" hljs avrasm">这是UserInfo类的afterReturningTest方法！
<span class="hljs-number">2016</span>-<span class="hljs-number">06</span>-<span class="hljs-number">02</span> <span class="hljs-number">15</span>:<span class="hljs-number">56</span>:<span class="hljs-number">08</span>,<span class="hljs-number">334</span> INFO [<span class="hljs-keyword">com</span><span class="hljs-preprocessor">.bc</span><span class="hljs-preprocessor">.aop</span><span class="hljs-preprocessor">.demo</span>02<span class="hljs-preprocessor">.MyLogger</span>] - 这是MyLogger类的after-returning方法！
切入点方法入参列表：[<span class="hljs-number">2</span>]
切入点方法签名对象：String <span class="hljs-keyword">com</span><span class="hljs-preprocessor">.bc</span><span class="hljs-preprocessor">.aop</span><span class="hljs-preprocessor">.demo</span>02<span class="hljs-preprocessor">.UserInfo</span><span class="hljs-preprocessor">.afterReturningTest</span>(int)
切入点所在目标对象：<span class="hljs-keyword">com</span><span class="hljs-preprocessor">.bc</span><span class="hljs-preprocessor">.aop</span><span class="hljs-preprocessor">.demo</span>02<span class="hljs-preprocessor">.UserInfo</span><span class="hljs-localvars">@139982</span>de
代理对象本身：<span class="hljs-keyword">com</span><span class="hljs-preprocessor">.bc</span><span class="hljs-preprocessor">.aop</span><span class="hljs-preprocessor">.demo</span>02<span class="hljs-preprocessor">.UserInfo</span><span class="hljs-localvars">@139982</span>de
切入点方法返回对象：afterReturningTest方法返回值</code></pre> 
 <p>结论  <strong>从控制台输出看出,后置增强会在切入点方法执行之后,再执行增强方法,因此除了可以像前置增强那样获取切入点方法的相关信息,还可以获取切入点方法的返回值,此外如果切入点方法没有正常执行,如抛出异常,则不会执行后置增强方法。</strong></p> 
 <hr> 
 <ul> 
  <li><strong>后置异常增强</strong></li> 
 </ul> 
 <p>配置</p> 
 <pre class="prettyprint"><code class=" hljs oxygene">&lt;aop:after-throwing <span class="hljs-function"><span class="hljs-keyword">method</span>="<span class="hljs-title">afterThrowing</span>" <span class="hljs-title">pointcut</span>-<span class="hljs-title">ref</span>="<span class="hljs-title">pointcut</span>" <span class="hljs-title">throwing</span>="<span class="hljs-title">e</span>"/&gt;</span></code></pre> 
 <p>测试代码</p> 
 <pre class="prettyprint"><code class=" hljs cs">ApplicationContext ac = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"applicationContext.xml"</span>);
UserInfo user = (UserInfo) ac.getBean(<span class="hljs-string">"userInfo"</span>);
<span class="hljs-keyword">try</span> {
<span class="hljs-comment">//后置异常增强测试</span>
user.afterThrowingTest(<span class="hljs-number">3</span>);</code></pre> 
 <p>控制台</p> 
 <pre class="prettyprint"><code class=" hljs avrasm">这是UserInfo类的afterReturningTest方法！
这是UserInfo类的afterThrowingTest方法！
<span class="hljs-number">2016</span>-<span class="hljs-number">06</span>-<span class="hljs-number">02</span> <span class="hljs-number">16</span>:<span class="hljs-number">00</span>:<span class="hljs-number">53</span>,<span class="hljs-number">481</span> INFO [<span class="hljs-keyword">com</span><span class="hljs-preprocessor">.bc</span><span class="hljs-preprocessor">.aop</span><span class="hljs-preprocessor">.demo</span>02<span class="hljs-preprocessor">.MyLogger</span>] - 这是MyLogger类的after-Throwing方法！
切入点方法入参列表：[<span class="hljs-number">3</span>]
切入点方法签名对象：String <span class="hljs-keyword">com</span><span class="hljs-preprocessor">.bc</span><span class="hljs-preprocessor">.aop</span><span class="hljs-preprocessor">.demo</span>02<span class="hljs-preprocessor">.UserInfo</span><span class="hljs-preprocessor">.afterThrowingTest</span>(int)
切入点所在目标对象：<span class="hljs-keyword">com</span><span class="hljs-preprocessor">.bc</span><span class="hljs-preprocessor">.aop</span><span class="hljs-preprocessor">.demo</span>02<span class="hljs-preprocessor">.UserInfo</span><span class="hljs-localvars">@385</span>c9627
代理对象本身：<span class="hljs-keyword">com</span><span class="hljs-preprocessor">.bc</span><span class="hljs-preprocessor">.aop</span><span class="hljs-preprocessor">.demo</span>02<span class="hljs-preprocessor">.UserInfo</span><span class="hljs-localvars">@385</span>c9627
异常：java<span class="hljs-preprocessor">.lang</span><span class="hljs-preprocessor">.RuntimeException</span>: afterThrowingTest方法抛出的异常</code></pre> 
 <p>结论  <strong>从控制台输出看出,后置异常增强会在切入点方法抛出异常的时候执行异常增强方法,除了可以获取方法相关信息之外也可以获取对应的异常信息。</strong></p> 
 <hr> 
 <ul> 
  <li><strong>最终增强</strong></li> 
 </ul> 
 <p>配置</p> 
 <pre class="prettyprint"><code class=" hljs oxygene">&lt;aop:after <span class="hljs-function"><span class="hljs-keyword">method</span>="<span class="hljs-title">after</span>" <span class="hljs-title">pointcut</span>-<span class="hljs-title">ref</span>="<span class="hljs-title">pointcut</span>"/&gt;</span></code></pre> 
 <p>测试代码</p> 
 <pre class="prettyprint"><code class=" hljs php">ApplicationContext ac = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"applicationContext.xml"</span>);
UserInfo user = (UserInfo) ac.getBean(<span class="hljs-string">"userInfo"</span>);
<span class="hljs-keyword">try</span> {
user.afterTest(<span class="hljs-number">4</span>);
} <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">Exception</span> e) {}</code></pre> 
 <p>控制台</p> 
 <pre class="prettyprint"><code class=" hljs avrasm">这是UserInfo类的afterTest方法！
<span class="hljs-number">2016</span>-<span class="hljs-number">06</span>-<span class="hljs-number">02</span> <span class="hljs-number">16</span>:<span class="hljs-number">06</span>:<span class="hljs-number">15</span>,<span class="hljs-number">169</span> INFO [<span class="hljs-keyword">com</span><span class="hljs-preprocessor">.bc</span><span class="hljs-preprocessor">.aop</span><span class="hljs-preprocessor">.demo</span>02<span class="hljs-preprocessor">.MyLogger</span>] - 这是MyLogger类的after方法！
切入点方法入参列表：[<span class="hljs-number">4</span>]
切入点方法签名对象：String <span class="hljs-keyword">com</span><span class="hljs-preprocessor">.bc</span><span class="hljs-preprocessor">.aop</span><span class="hljs-preprocessor">.demo</span>02<span class="hljs-preprocessor">.UserInfo</span><span class="hljs-preprocessor">.afterTest</span>(int)
切入点所在目标对象：<span class="hljs-keyword">com</span><span class="hljs-preprocessor">.bc</span><span class="hljs-preprocessor">.aop</span><span class="hljs-preprocessor">.demo</span>02<span class="hljs-preprocessor">.UserInfo</span><span class="hljs-localvars">@7586</span>beff
代理对象本身：<span class="hljs-keyword">com</span><span class="hljs-preprocessor">.bc</span><span class="hljs-preprocessor">.aop</span><span class="hljs-preprocessor">.demo</span>02<span class="hljs-preprocessor">.UserInfo</span><span class="hljs-localvars">@7586</span>beff</code></pre> 
 <p>结论  <strong>从控制台和切入点方法可以看出,最终增强无论切入点方法是否正常执行完毕,都会执行增强方法,因此不可以获取返回值或者异常,只可以获取和前置增强相同的信息。</strong></p> 
 <hr> 
 <ul> 
  <li><strong>环绕增强</strong></li> 
 </ul> 
 <p>配置</p> 
 <pre class="prettyprint"><code class=" hljs oxygene">&lt;aop:around <span class="hljs-function"><span class="hljs-keyword">method</span>="<span class="hljs-title">aroundLogger</span>" <span class="hljs-title">pointcut</span>-<span class="hljs-title">ref</span>="<span class="hljs-title">pointcut</span>"/&gt;</span></code></pre> 
 <p>测试代码</p> 
 <pre class="prettyprint"><code class=" hljs cs">ApplicationContext ac = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"applicationContext.xml"</span>);
UserInfo user = (UserInfo) ac.getBean(<span class="hljs-string">"userInfo"</span>);

<span class="hljs-comment">//环绕增强测试</span>
user.aroundTest(<span class="hljs-number">5</span>);</code></pre> 
 <p>控制台</p> 
 <pre class="prettyprint"><code class=" hljs avrasm"><span class="hljs-number">2016</span>-<span class="hljs-number">06</span>-<span class="hljs-number">02</span> <span class="hljs-number">16</span>:<span class="hljs-number">12</span>:<span class="hljs-number">00</span>,<span class="hljs-number">054</span> INFO [<span class="hljs-keyword">com</span><span class="hljs-preprocessor">.bc</span><span class="hljs-preprocessor">.aop</span><span class="hljs-preprocessor">.demo</span>02<span class="hljs-preprocessor">.MyLogger</span>] - 这是MyLogger类的around方法！
切入点方法入参列表：[<span class="hljs-number">5</span>]
切入点方法签名对象：String <span class="hljs-keyword">com</span><span class="hljs-preprocessor">.bc</span><span class="hljs-preprocessor">.aop</span><span class="hljs-preprocessor">.demo</span>02<span class="hljs-preprocessor">.UserInfo</span><span class="hljs-preprocessor">.aroundTest</span>(int)
切入点所在目标对象：<span class="hljs-keyword">com</span><span class="hljs-preprocessor">.bc</span><span class="hljs-preprocessor">.aop</span><span class="hljs-preprocessor">.demo</span>02<span class="hljs-preprocessor">.UserInfo</span><span class="hljs-localvars">@557</span>caf28
代理对象本身：<span class="hljs-keyword">com</span><span class="hljs-preprocessor">.bc</span><span class="hljs-preprocessor">.aop</span><span class="hljs-preprocessor">.demo</span>02<span class="hljs-preprocessor">.UserInfo</span><span class="hljs-localvars">@557</span>caf28
-------------------------------
执行切入点方法
这是UserInfo类的aroundTest方法！参数值：<span class="hljs-number">5</span>
-------------------------------
执行切入点方法并改变参数
这是UserInfo类的aroundTest方法！参数值：<span class="hljs-number">7</span></code></pre> 
 <p>结论  <strong>环绕增强比较特殊,如果一个方法配置了环绕增强,那么执行此方法只会执行环绕增强的方法,然后可以在环绕增强的方法中通过JoinPoint或ProceedingJoinPoint(只对环绕增强有效,其余增强使用此对象会报错)获取切入点方法的相关信息,同时,使用ProceedingJoinPoint还可以执行N次切入点方法,也可以改变切入点方法的参数数值（参数数量需要保持相同）,因此,使用环绕增强,要想执行切入点方法需要在增强方法内调用ProceedingJoinPoint对象的proceed()方法来执行切入点方法。</strong></p> 
 <hr> 
 <h2 id="三使用注解方式配置aop">三、使用注解方式配置AOP</h2> 
 <p><strong>首先先修改下applicationContext.xml配置文件</strong></p> 
 <pre class="prettyprint"><code class=" hljs xml"><span class="hljs-comment">&lt;!-- 打开切面注解 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">aop:aspectj-autoproxy</span> <span class="hljs-attribute">proxy-target-class</span>=<span class="hljs-value">"true"</span>/&gt;</span>
<span class="hljs-comment">&lt;!-- 扫描注解包 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">context:component-scan</span> <span class="hljs-attribute">base-package</span>=<span class="hljs-value">"com.bc"</span>/&gt;</span></code></pre> 
 <p><strong>然后用上面的MyLogger类来改</strong></p> 
 <pre class="prettyprint"><code class=" hljs java"><span class="hljs-annotation">@Aspect</span>
<span class="hljs-annotation">@Component</span><span class="hljs-comment">//必须有这个注解</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyLogger</span> {</span>

    <span class="hljs-keyword">private</span> Logger logger = Logger.getLogger(MyLogger.class);

    <span class="hljs-comment">//定义一个切入点</span>
    <span class="hljs-annotation">@Pointcut</span>(<span class="hljs-string">"execution(public * com.bc.aop..*.*(..))"</span>)
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pointcut</span>() {}

    <span class="hljs-javadoc">/**前置增强方法*/</span>
    <span class="hljs-annotation">@Before</span>(<span class="hljs-string">"pointcut()"</span>)
    <span class="hljs-comment">//@Before("execution(public * com.bc.aop..*.*(..))")可以给方法单独指定切入点</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforeLogger</span>(JoinPoint jp) {
        logger.info(<span class="hljs-string">"这是MyLogger类的before方法！"</span>);
        System.out.println(<span class="hljs-string">"切入点方法入参列表："</span> + Arrays.toString(jp.getArgs()));
        System.out.println(<span class="hljs-string">"切入点方法签名对象："</span> + jp.getSignature());
        System.out.println(<span class="hljs-string">"切入点所在目标对象："</span> + jp.getTarget());
        System.out.println(<span class="hljs-string">"代理对象本身："</span> + jp.getThis());
    }

    <span class="hljs-javadoc">/**后置增强方法*/</span>
    <span class="hljs-annotation">@AfterReturning</span>(pointcut = <span class="hljs-string">"pointcut()"</span>, returning = <span class="hljs-string">"result"</span>)
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterReturning</span>(JoinPoint jp, Object result) {
        logger.info(<span class="hljs-string">"这是MyLogger类的after-returning方法！"</span>);
        System.out.println(<span class="hljs-string">"切入点方法入参列表："</span> + Arrays.toString(jp.getArgs()));
        System.out.println(<span class="hljs-string">"切入点方法签名对象："</span> + jp.getSignature());
        System.out.println(<span class="hljs-string">"切入点所在目标对象："</span> + jp.getTarget());
        System.out.println(<span class="hljs-string">"代理对象本身："</span> + jp.getThis());
        System.out.println(<span class="hljs-string">"切入点方法返回对象："</span> + result);
    }

    <span class="hljs-javadoc">/**后置异常增强方法*/</span>
    <span class="hljs-annotation">@AfterThrowing</span>(pointcut = <span class="hljs-string">"pointcut()"</span>, throwing = <span class="hljs-string">"e"</span>)
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterThrowing</span>(JoinPoint jp, Exception e) {
        logger.info(<span class="hljs-string">"这是MyLogger类的after-Throwing方法！"</span>);
        System.out.println(<span class="hljs-string">"切入点方法入参列表："</span> + Arrays.toString(jp.getArgs()));
        System.out.println(<span class="hljs-string">"切入点方法签名对象："</span> + jp.getSignature());
        System.out.println(<span class="hljs-string">"切入点所在目标对象："</span> + jp.getTarget());
        System.out.println(<span class="hljs-string">"代理对象本身："</span> + jp.getThis());
        System.out.println(<span class="hljs-string">"异常："</span> + e);
    }

    <span class="hljs-javadoc">/**最终增强方法*/</span>
    <span class="hljs-annotation">@After</span>(<span class="hljs-string">"pointcut()"</span>)
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span>(JoinPoint jp) {
        logger.info(<span class="hljs-string">"这是MyLogger类的after方法！"</span>);
        System.out.println(<span class="hljs-string">"切入点方法入参列表："</span> + Arrays.toString(jp.getArgs()));
        System.out.println(<span class="hljs-string">"切入点方法签名对象："</span> + jp.getSignature());
        System.out.println(<span class="hljs-string">"切入点所在目标对象："</span> + jp.getTarget());
        System.out.println(<span class="hljs-string">"代理对象本身："</span> + jp.getThis());
    }

    <span class="hljs-javadoc">/**环绕增强方法*/</span>
    <span class="hljs-annotation">@Around</span>(<span class="hljs-string">"pointcut()"</span>)
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">aroundLogger</span>(ProceedingJoinPoint jp) {
        logger.info(<span class="hljs-string">"这是MyLogger类的around方法！"</span>);
        System.out.println(<span class="hljs-string">"切入点方法入参列表："</span> + Arrays.toString(jp.getArgs()));
        System.out.println(<span class="hljs-string">"切入点方法签名对象："</span> + jp.getSignature());
        System.out.println(<span class="hljs-string">"切入点所在目标对象："</span> + jp.getTarget());
        System.out.println(<span class="hljs-string">"代理对象本身："</span> + jp.getThis());
        System.out.println(<span class="hljs-string">"-------------------------------"</span>);
        <span class="hljs-keyword">try</span> {
            System.out.println(<span class="hljs-string">"执行切入点方法"</span>);
            jp.proceed();
            System.out.println(<span class="hljs-string">"-------------------------------"</span>);
            System.out.println(<span class="hljs-string">"执行切入点方法并改变参数"</span>);
            jp.proceed(<span class="hljs-keyword">new</span> Object[]{<span class="hljs-number">7</span>});
        } <span class="hljs-keyword">catch</span> (Throwable e) {
            e.printStackTrace();
        }
    }
}</code></pre> 
 <p><strong>切入点测试类代码</strong></p> 
 <pre class="prettyprint"><code class=" hljs cs">@Service(<span class="hljs-string">"person"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Person {

    <span class="hljs-keyword">public</span> String <span class="hljs-title">personTest</span>(<span class="hljs-keyword">int</span> i) {
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"这是Person类的personTest方法,参数值："</span> + i);
        <span class="hljs-keyword">return</span> <span class="hljs-string">"personTest方法返回值"</span>;
    }
}</code></pre> 
 <p><strong>测试代码</strong></p> 
 <pre class="prettyprint"><code class=" hljs avrasm">ApplicationContext ac = new ClassPathXmlApplicationContext(<span class="hljs-string">"applicationContext.xml"</span>)<span class="hljs-comment">;</span>
Person person = (Person) ac<span class="hljs-preprocessor">.getBean</span>(<span class="hljs-string">"person"</span>)<span class="hljs-comment">;</span>
person<span class="hljs-preprocessor">.personTest</span>(<span class="hljs-number">1</span>)<span class="hljs-comment">;</span></code></pre> 
 <p><strong>控制台</strong></p> 
 <pre class="prettyprint"><code class=" hljs avrasm"><span class="hljs-number">2016</span>-<span class="hljs-number">06</span>-<span class="hljs-number">02</span> <span class="hljs-number">16</span>:<span class="hljs-number">48</span>:<span class="hljs-number">11</span>,<span class="hljs-number">347</span> INFO [<span class="hljs-keyword">com</span><span class="hljs-preprocessor">.bc</span><span class="hljs-preprocessor">.aop</span><span class="hljs-preprocessor">.demo</span>03<span class="hljs-preprocessor">.MyLogger</span>] - 这是MyLogger类的around方法！
切入点方法入参列表：[<span class="hljs-number">1</span>]
切入点方法签名对象：String <span class="hljs-keyword">com</span><span class="hljs-preprocessor">.bc</span><span class="hljs-preprocessor">.aop</span><span class="hljs-preprocessor">.demo</span>03<span class="hljs-preprocessor">.Person</span><span class="hljs-preprocessor">.personTest</span>(int)
切入点所在目标对象：<span class="hljs-keyword">com</span><span class="hljs-preprocessor">.bc</span><span class="hljs-preprocessor">.aop</span><span class="hljs-preprocessor">.demo</span>03<span class="hljs-preprocessor">.Person</span><span class="hljs-localvars">@1</span>a4013
代理对象本身：<span class="hljs-keyword">com</span><span class="hljs-preprocessor">.bc</span><span class="hljs-preprocessor">.aop</span><span class="hljs-preprocessor">.demo</span>03<span class="hljs-preprocessor">.Person</span><span class="hljs-localvars">@1</span>a4013
-------------------------------
执行切入点方法
<span class="hljs-number">2016</span>-<span class="hljs-number">06</span>-<span class="hljs-number">02</span> <span class="hljs-number">16</span>:<span class="hljs-number">48</span>:<span class="hljs-number">11</span>,<span class="hljs-number">367</span> INFO [<span class="hljs-keyword">com</span><span class="hljs-preprocessor">.bc</span><span class="hljs-preprocessor">.aop</span><span class="hljs-preprocessor">.demo</span>03<span class="hljs-preprocessor">.MyLogger</span>] - 这是MyLogger类的before方法！
切入点方法入参列表：[<span class="hljs-number">1</span>]
切入点方法签名对象：String <span class="hljs-keyword">com</span><span class="hljs-preprocessor">.bc</span><span class="hljs-preprocessor">.aop</span><span class="hljs-preprocessor">.demo</span>03<span class="hljs-preprocessor">.Person</span><span class="hljs-preprocessor">.personTest</span>(int)
切入点所在目标对象：<span class="hljs-keyword">com</span><span class="hljs-preprocessor">.bc</span><span class="hljs-preprocessor">.aop</span><span class="hljs-preprocessor">.demo</span>03<span class="hljs-preprocessor">.Person</span><span class="hljs-localvars">@1</span>a4013
代理对象本身：<span class="hljs-keyword">com</span><span class="hljs-preprocessor">.bc</span><span class="hljs-preprocessor">.aop</span><span class="hljs-preprocessor">.demo</span>03<span class="hljs-preprocessor">.Person</span><span class="hljs-localvars">@1</span>a4013
这是Person类的personTest方法,参数值：<span class="hljs-number">1</span>
-------------------------------
执行切入点方法并改变参数
<span class="hljs-number">2016</span>-<span class="hljs-number">06</span>-<span class="hljs-number">02</span> <span class="hljs-number">16</span>:<span class="hljs-number">48</span>:<span class="hljs-number">11</span>,<span class="hljs-number">371</span> INFO [<span class="hljs-keyword">com</span><span class="hljs-preprocessor">.bc</span><span class="hljs-preprocessor">.aop</span><span class="hljs-preprocessor">.demo</span>03<span class="hljs-preprocessor">.MyLogger</span>] - 这是MyLogger类的before方法！
切入点方法入参列表：[<span class="hljs-number">1</span>]
切入点方法签名对象：String <span class="hljs-keyword">com</span><span class="hljs-preprocessor">.bc</span><span class="hljs-preprocessor">.aop</span><span class="hljs-preprocessor">.demo</span>03<span class="hljs-preprocessor">.Person</span><span class="hljs-preprocessor">.personTest</span>(int)
切入点所在目标对象：<span class="hljs-keyword">com</span><span class="hljs-preprocessor">.bc</span><span class="hljs-preprocessor">.aop</span><span class="hljs-preprocessor">.demo</span>03<span class="hljs-preprocessor">.Person</span><span class="hljs-localvars">@1</span>a4013
代理对象本身：<span class="hljs-keyword">com</span><span class="hljs-preprocessor">.bc</span><span class="hljs-preprocessor">.aop</span><span class="hljs-preprocessor">.demo</span>03<span class="hljs-preprocessor">.Person</span><span class="hljs-localvars">@1</span>a4013
这是Person类的personTest方法,参数值：<span class="hljs-number">7</span>
<span class="hljs-number">2016</span>-<span class="hljs-number">06</span>-<span class="hljs-number">02</span> <span class="hljs-number">16</span>:<span class="hljs-number">48</span>:<span class="hljs-number">11</span>,<span class="hljs-number">372</span> INFO [<span class="hljs-keyword">com</span><span class="hljs-preprocessor">.bc</span><span class="hljs-preprocessor">.aop</span><span class="hljs-preprocessor">.demo</span>03<span class="hljs-preprocessor">.MyLogger</span>] - 这是MyLogger类的after方法！
切入点方法入参列表：[<span class="hljs-number">1</span>]
切入点方法签名对象：String <span class="hljs-keyword">com</span><span class="hljs-preprocessor">.bc</span><span class="hljs-preprocessor">.aop</span><span class="hljs-preprocessor">.demo</span>03<span class="hljs-preprocessor">.Person</span><span class="hljs-preprocessor">.personTest</span>(int)
切入点所在目标对象：<span class="hljs-keyword">com</span><span class="hljs-preprocessor">.bc</span><span class="hljs-preprocessor">.aop</span><span class="hljs-preprocessor">.demo</span>03<span class="hljs-preprocessor">.Person</span><span class="hljs-localvars">@1</span>a4013
代理对象本身：<span class="hljs-keyword">com</span><span class="hljs-preprocessor">.bc</span><span class="hljs-preprocessor">.aop</span><span class="hljs-preprocessor">.demo</span>03<span class="hljs-preprocessor">.Person</span><span class="hljs-localvars">@1</span>a4013
<span class="hljs-number">2016</span>-<span class="hljs-number">06</span>-<span class="hljs-number">02</span> <span class="hljs-number">16</span>:<span class="hljs-number">48</span>:<span class="hljs-number">11</span>,<span class="hljs-number">372</span> INFO [<span class="hljs-keyword">com</span><span class="hljs-preprocessor">.bc</span><span class="hljs-preprocessor">.aop</span><span class="hljs-preprocessor">.demo</span>03<span class="hljs-preprocessor">.MyLogger</span>] - 这是MyLogger类的after-returning方法！
切入点方法入参列表：[<span class="hljs-number">1</span>]
切入点方法签名对象：String <span class="hljs-keyword">com</span><span class="hljs-preprocessor">.bc</span><span class="hljs-preprocessor">.aop</span><span class="hljs-preprocessor">.demo</span>03<span class="hljs-preprocessor">.Person</span><span class="hljs-preprocessor">.personTest</span>(int)
切入点所在目标对象：<span class="hljs-keyword">com</span><span class="hljs-preprocessor">.bc</span><span class="hljs-preprocessor">.aop</span><span class="hljs-preprocessor">.demo</span>03<span class="hljs-preprocessor">.Person</span><span class="hljs-localvars">@1</span>a4013
代理对象本身：<span class="hljs-keyword">com</span><span class="hljs-preprocessor">.bc</span><span class="hljs-preprocessor">.aop</span><span class="hljs-preprocessor">.demo</span>03<span class="hljs-preprocessor">.Person</span><span class="hljs-localvars">@1</span>a4013
切入点方法返回对象：null</code></pre> 
 <p><strong>注解的方式可以大大减少配置代码,但是个人也不是很喜欢这种侵入式配置,不利于后期维护</strong></p>
</div>