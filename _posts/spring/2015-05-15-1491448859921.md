---
layout:  post
title:  " Maven管理的Spring Web项目集成JUnit单元测试 "
date:    2015-05-15
excerpt: " JUnit是一套优秀的单元测试框架，而Maven是优秀的Java项目构建和管理工具，两者结合可以很方便地对项目进行自动化测试。　　一般的简单Java应用就不多说了，一些框架会提供针对junit的扩展，使得测试变得更容易，例如Spring官方就提供了spring-test，用于提供获取ApplicationContext等方面的支持。　　首先要做的是，改变JUnit的实际执行类，将默认的执行类Suite替换为Spring提供的SpringJUnit4ClassRunner，也就是在测试类前面加上一个注解：　　@RunWith(SpringJUnit4ClassRunner.class)　　然后，我们需要告诉这个测试类Spring配置文件的位置：@ContextConfiguration(locations={“classpath:applicationContext.xml”,“classpath:applicationContext-security.xml”，”file:src/main/webapp/WEB-INF/servlet.xml”})　　笔者这里展示了两种配置文件路径的写法。前两个是spring常见的配置文件，放在classpath根目录下，而“file”开头的路径是完全限定路径，默认是相对于实际的项目路径的，例如笔者使用Eclipse进行开发，这个路径的写法是相对于项目文件所在文件夹的根目录的。该写法适用于没有直接放在classpath下的一些web相关的配置文件，例如本例展示的就是放在常见的WEB-INF目录下的一个文件。　　基于以上描述，笔者写了一个Spring测试基类：packagecom.test.basic;importorg.apache.commons.logging.Log;importorg.apache.commons.logging.LogFactory;importorg.junit.Before;importorg.junit.runner.RunWith;importorg.springframework.test.context.ContextConfiguration;importorg.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations={/“file:src/main/webapp/WEB-INF/wxiot-servlet.xml”,/“classpath:app... "
categories: spring 
comments: true
---
转自 (csdn): http://blog.csdn.net/wo541075754/article/details/45740783
<div class="markdown_views">
 <p>JUnit是一套优秀的单元测试框架，而Maven是优秀的Java项目构建和管理工具，两者结合可以很方便地对项目进行自动化测试。  　　一般的简单Java应用就不多说了，一些框架会提供针对junit的扩展，使得测试变得更容易，例如Spring官方就提供了spring-test，用于提供获取ApplicationContext等方面的支持。  　　首先要做的是，改变JUnit的实际执行类，将默认的执行类Suite替换为Spring提供的SpringJUnit4ClassRunner，也就是在测试类前面加上一个注解：  　　@RunWith(SpringJUnit4ClassRunner.class)  　　然后，我们需要告诉这个测试类Spring配置文件的位置：  @ContextConfiguration(locations={“classpath:applicationContext.xml”,  “classpath:applicationContext-security.xml”，”file:src/main/webapp/WEB-INF/servlet.xml”})  　　笔者这里展示了两种配置文件路径的写法。前两个是spring常见的配置文件，放在classpath根目录下，而“file”开头的路径是完全限定路径，默认是相对于实际的项目路径的，例如笔者使用Eclipse进行开发，这个路径的写法是相对于项目文件所在文件夹的根目录的。该写法适用于没有直接放在classpath下的一些web相关的配置文件，例如本例展示的就是放在常见的WEB-INF目录下的一个文件。  　　基于以上描述，笔者写了一个Spring测试基类：  package com.test.basic;  import org.apache.commons.logging.Log;  import org.apache.commons.logging.LogFactory;  import org.junit.Before;  import org.junit.runner.RunWith;  import org.springframework.test.context.ContextConfiguration;  import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;  @RunWith(SpringJUnit4ClassRunner.class)  @ContextConfiguration(locations={/<em>“file:src/main/webapp/WEB-INF/wxiot-servlet.xml”,</em>/ “classpath:applicationContext.xml”,  “classpath:applicationContext-security.xml”})  public classTestBase {  protected Log logger = LogFactory.getLog(TestBase.class);  @Before  //一些公用的“初始化”代码  public void before(){  }  }</p> 
 <p>　　有了这个基类，我们就可以动手写各个模块的测试类了，只要在定义测试类的时候继承TestBase，并在具体的方法前面加上@Test注解，笔者这里给出一个测试类的简单示例：  import org.junit.Assert;  import org.junit.Test;  import org.springframework.beans.factory.annotation.Autowired;  import com.reports.util.ActiveMQSender;  import com.test.basic.TestBase;  public classActiveMQSenderTest extends TestBase {  @Autowired  ActiveMQSendersender;  @Test  public void sendQTest(){  Assert.assertNull(sender.sendInformationQ(“发，布。到？队！列“的￥信息”, “20131023102122”, “20131025102122”));  Assert.assertNotNull(sender.sendInformationQ(“发，布。到？队！列“的￥信息”, “20131023102122”, “2013-10-26 10:21:22”));  }  @Test  public void sendTopicTest(){  Assert.assertNull(sender.sendInformationTopic(“发，布。到？Topic！的”信￥息”, “20131023102122”,”20131025102122”) );  }  }  　　最后执行“RunAs -&gt; JUnit Test”即可开始JUnit单元测试了，使用Maven命令还可以方便地对特定目录下（通常是src/test/java目录）的所有测试类进行批量测试。  　　对于Java Web项目，某些业务类可能会带有使用ServletContext等Web容器相关类的代码，对于这些类我们就不能直接用JUnit来测试了，因为默认JUnit是没有Web容器的，我们通常需要借助其它相关的辅助类或者模拟Web容器来进行测试，例如利用struts2-junit-plugin的帮助来测试struts的action，这些内容网上的资料很多，不在本文的讨论范围之内。  　　一些用到了web容器的业务类只需稍加修改，就可以直接用于JUnit测试。假设一个业务类使用了ServletContext来获取容器内的资源，例如一个配置文件：  　　InputStream is=context.getResourceAsStream(“/WEB-INF/configs/command-sender.xml”);  　　其中context变量保存了Web容器的ServletContext，如果直接使用JUnit来测试，必然导致空指针异常。此时我们可以稍作修改：  InputStream is = null;  if(null != context){  is= context.getResourceAsStream(“/WEB-INF/configs/command-sender.xml”);  }else{//JUnit Test环境下，使用ApplicationContext获取配置文件  //NearEast 2013-10-22  try {  is= SpringContextHolder.getApplicationContext().  getResource(“file:src/main/webapp/WEB-INF/configs/command-sender.xml”).getInputStream();  }catch(IOException e) {  e.printStackTrace();  }  }  　　其中，SpringContextHolder是笔者在《在Java Web应用中获取Spring管理的Bean的方法》提到的一个工具类，SpringContextHolder.getApplicationContext()即获得Spring的ApplicationContext。资源的路径使用了上文提到的完全限定路径，我们也可以将其写为类似“file:E:/Workspaces/workspace_test/test/src/main/webapp/WEB-INF/configs/command-sender.xml””的形式。经过上述修改之后，我们的业务类也可以直接利用JUnit执行测试了。  　　当然我们还可以用其它方式获取ApplicationContext，例如让业务类实现ApplicationContextAware接口，并使用一个变量保存ApplicationContext。</p> 
 <p>原文地址：<a href="http://www.blogjava.net/qileilove/archive/2013/10/31/405835.html">http://www.blogjava.net/qileilove/archive/2013/10/31/405835.html</a></p>
</div>